//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"crypto/ecdsa"
	"encoding/hex"
	"flag"
	"go/format"
	"io/ioutil"
	"text/template"

	"github.com/ethereum/go-ethereum/crypto"
)

var (
	tmpl = template.Must(template.New("").Parse(`// This file is autogenerated. DO NOT MODIFY BY HAND
// To regenerate, run "go generate"

package ethtest

import (
	"crypto/ecdsa"
	"sync"

	"github.com/ethereum/go-ethereum/crypto"
)

var (

	keysMu sync.Mutex
	keysIdx int
	keys = []*ecdsa.PrivateKey {
{{- range .Keys }}
		mustHexToECDSA("{{ . }}"),
{{- end }}
	}

)

func mustHexToECDSA(x string) *ecdsa.PrivateKey {
	key, err := crypto.HexToECDSA(x)
	if err != nil {
		panic(err)
	}
	return key
}

// NewKey returns a pre-generated test key.
func NewKey() *ecdsa.PrivateKey {
	keysMu.Lock()
	defer keysMu.Unlock()
	if keysIdx >= len(keys) {
		panic("not enough pre-generated keys for new key")
	}
	key := keys[keysIdx]
	keysIdx++
	return key
}
`))
)

func main() {
	numKeys := flag.Int("num-keys", 10, "number of keys to generate")
	outFlag := flag.String("out", "generate.out.go", "output file")
	flag.Parse()

	var keys []string
	for i := 0; i < *numKeys; i++ {
		key := generateKey()
		keys = append(keys, hex.EncodeToString(crypto.FromECDSA(key)))
	}

	buf := new(bytes.Buffer)
	err := tmpl.Execute(buf, map[string]interface{}{
		"Keys": keys,
	})
	check(err)

	source, err := format.Source(buf.Bytes())
	check(err)
	check(ioutil.WriteFile(*outFlag, source, 0644))
}

func generateKey() *ecdsa.PrivateKey {
	key, err := crypto.GenerateKey()
	check(err)
	return key
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}
