// AUTOGENERATED BY storj.io/dbx
// DO NOT EDIT.

package payoutdb

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/mattn/go-sqlite3"
)

// Prevent conditional imports from causing build failures.
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr = func(err *Error) error { return err }
	Logger  func(format string, args ...interface{})

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...interface{}) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	e := &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}

var (
	notAPointer     = errors.New("destination not a pointer")
	lossyConversion = errors.New("lossy conversion")
)

type DB struct {
	*sql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "sqlite3":
		sql_db, err = opensqlite3(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			_ = sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	db = &DB{
		DB: sql_db,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "sqlite3":
		db.dbMethods = newsqlite3(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func (obj *DB) NewRx() *Rx {
	return &Rx{db: obj}
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type sqlite3Impl struct {
	db      *DB
	dialect __sqlbundle_sqlite3
	driver  driver
}

func (obj *sqlite3Impl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *sqlite3Impl) logStmt(stmt string, args ...interface{}) {
	sqlite3LogStmt(stmt, args...)
}

func (obj *sqlite3Impl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type sqlite3DB struct {
	db *DB
	*sqlite3Impl
}

func newsqlite3(db *DB) *sqlite3DB {
	return &sqlite3DB{
		db: db,
		sqlite3Impl: &sqlite3Impl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *sqlite3DB) Schema() string {
	return `CREATE TABLE metadata (
	pk INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	updated_at TIMESTAMP NOT NULL,
	version INTEGER NOT NULL,
	attempts INTEGER NOT NULL,
	spender TEXT,
	owner TEXT,
	PRIMARY KEY ( pk )
);
CREATE TABLE payout_group (
	pk INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	updated_at TIMESTAMP NOT NULL,
	id INTEGER NOT NULL,
	final_tx_hash TEXT,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
);
CREATE TABLE payout (
	pk INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	csv_line INTEGER NOT NULL,
	payee TEXT NOT NULL,
	usd TEXT NOT NULL,
	payout_group_id INTEGER NOT NULL REFERENCES payout_group( id ),
	PRIMARY KEY ( pk )
);
CREATE TABLE tx (
	pk INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	updated_at TIMESTAMP NOT NULL,
	hash TEXT NOT NULL,
	owner TEXT NOT NULL,
	spender TEXT NOT NULL,
	nonce INTEGER NOT NULL,
	estimated_gas_price TEXT NOT NULL,
	storj_price TEXT NOT NULL,
	storj_tokens TEXT NOT NULL,
	payout_group_id INTEGER NOT NULL REFERENCES payout_group( id ),
	raw TEXT NOT NULL,
	state TEXT NOT NULL,
	receipt TEXT,
	PRIMARY KEY ( pk ),
	UNIQUE ( hash )
);
CREATE INDEX payout_group_final_tx_hash_index ON payout_group ( final_tx_hash ) ;`
}

func (obj *sqlite3DB) wrapTx(tx *sql.Tx) txMethods {
	return &sqlite3Tx{
		dialectTx: dialectTx{tx: tx},
		sqlite3Impl: &sqlite3Impl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type sqlite3Tx struct {
	dialectTx
	*sqlite3Impl
}

func sqlite3LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []interface{}

func (p pretty) Format(f fmt.State, c rune) {
	fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			fmt.Fprintf(f, "%q", v)
		case time.Time:
			fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			fmt.Fprintf(f, "%q", v)
		default:
			fmt.Fprintf(f, "%v", v)
		}
	}
	fmt.Fprint(f, "]")
}

type Metadata struct {
	Pk        int64
	CreatedAt time.Time
	UpdatedAt time.Time
	Version   int
	Attempts  int
	Spender   *string
	Owner     *string
}

func (Metadata) _Table() string { return "metadata" }

type Metadata_Create_Fields struct {
	Spender Metadata_Spender_Field
	Owner   Metadata_Owner_Field
}

type Metadata_Update_Fields struct {
	Attempts Metadata_Attempts_Field
	Spender  Metadata_Spender_Field
	Owner    Metadata_Owner_Field
}

type Metadata_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Metadata_Pk(v int64) Metadata_Pk_Field {
	return Metadata_Pk_Field{_set: true, _value: v}
}

func (f Metadata_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Metadata_Pk_Field) _Column() string { return "pk" }

type Metadata_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Metadata_CreatedAt(v time.Time) Metadata_CreatedAt_Field {
	v = toUTC(v)
	return Metadata_CreatedAt_Field{_set: true, _value: v}
}

func (f Metadata_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Metadata_CreatedAt_Field) _Column() string { return "created_at" }

type Metadata_UpdatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Metadata_UpdatedAt(v time.Time) Metadata_UpdatedAt_Field {
	v = toUTC(v)
	return Metadata_UpdatedAt_Field{_set: true, _value: v}
}

func (f Metadata_UpdatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Metadata_UpdatedAt_Field) _Column() string { return "updated_at" }

type Metadata_Version_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Metadata_Version(v int) Metadata_Version_Field {
	return Metadata_Version_Field{_set: true, _value: v}
}

func (f Metadata_Version_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Metadata_Version_Field) _Column() string { return "version" }

type Metadata_Attempts_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Metadata_Attempts(v int) Metadata_Attempts_Field {
	return Metadata_Attempts_Field{_set: true, _value: v}
}

func (f Metadata_Attempts_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Metadata_Attempts_Field) _Column() string { return "attempts" }

type Metadata_Spender_Field struct {
	_set   bool
	_null  bool
	_value *string
}

func Metadata_Spender(v string) Metadata_Spender_Field {
	return Metadata_Spender_Field{_set: true, _value: &v}
}

func Metadata_Spender_Raw(v *string) Metadata_Spender_Field {
	if v == nil {
		return Metadata_Spender_Null()
	}
	return Metadata_Spender(*v)
}

func Metadata_Spender_Null() Metadata_Spender_Field {
	return Metadata_Spender_Field{_set: true, _null: true}
}

func (f Metadata_Spender_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Metadata_Spender_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Metadata_Spender_Field) _Column() string { return "spender" }

type Metadata_Owner_Field struct {
	_set   bool
	_null  bool
	_value *string
}

func Metadata_Owner(v string) Metadata_Owner_Field {
	return Metadata_Owner_Field{_set: true, _value: &v}
}

func Metadata_Owner_Raw(v *string) Metadata_Owner_Field {
	if v == nil {
		return Metadata_Owner_Null()
	}
	return Metadata_Owner(*v)
}

func Metadata_Owner_Null() Metadata_Owner_Field {
	return Metadata_Owner_Field{_set: true, _null: true}
}

func (f Metadata_Owner_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Metadata_Owner_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Metadata_Owner_Field) _Column() string { return "owner" }

type PayoutGroup struct {
	Pk          int64
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Id          int64
	FinalTxHash *string
}

func (PayoutGroup) _Table() string { return "payout_group" }

type PayoutGroup_Create_Fields struct {
	FinalTxHash PayoutGroup_FinalTxHash_Field
}

type PayoutGroup_Update_Fields struct {
	FinalTxHash PayoutGroup_FinalTxHash_Field
}

type PayoutGroup_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func PayoutGroup_Pk(v int64) PayoutGroup_Pk_Field {
	return PayoutGroup_Pk_Field{_set: true, _value: v}
}

func (f PayoutGroup_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PayoutGroup_Pk_Field) _Column() string { return "pk" }

type PayoutGroup_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func PayoutGroup_CreatedAt(v time.Time) PayoutGroup_CreatedAt_Field {
	v = toUTC(v)
	return PayoutGroup_CreatedAt_Field{_set: true, _value: v}
}

func (f PayoutGroup_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PayoutGroup_CreatedAt_Field) _Column() string { return "created_at" }

type PayoutGroup_UpdatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func PayoutGroup_UpdatedAt(v time.Time) PayoutGroup_UpdatedAt_Field {
	v = toUTC(v)
	return PayoutGroup_UpdatedAt_Field{_set: true, _value: v}
}

func (f PayoutGroup_UpdatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PayoutGroup_UpdatedAt_Field) _Column() string { return "updated_at" }

type PayoutGroup_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func PayoutGroup_Id(v int64) PayoutGroup_Id_Field {
	return PayoutGroup_Id_Field{_set: true, _value: v}
}

func (f PayoutGroup_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PayoutGroup_Id_Field) _Column() string { return "id" }

type PayoutGroup_FinalTxHash_Field struct {
	_set   bool
	_null  bool
	_value *string
}

func PayoutGroup_FinalTxHash(v string) PayoutGroup_FinalTxHash_Field {
	return PayoutGroup_FinalTxHash_Field{_set: true, _value: &v}
}

func PayoutGroup_FinalTxHash_Raw(v *string) PayoutGroup_FinalTxHash_Field {
	if v == nil {
		return PayoutGroup_FinalTxHash_Null()
	}
	return PayoutGroup_FinalTxHash(*v)
}

func PayoutGroup_FinalTxHash_Null() PayoutGroup_FinalTxHash_Field {
	return PayoutGroup_FinalTxHash_Field{_set: true, _null: true}
}

func (f PayoutGroup_FinalTxHash_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f PayoutGroup_FinalTxHash_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PayoutGroup_FinalTxHash_Field) _Column() string { return "final_tx_hash" }

type Payout struct {
	Pk            int64
	CreatedAt     time.Time
	CsvLine       int
	Payee         string
	Usd           string
	PayoutGroupId int64
}

func (Payout) _Table() string { return "payout" }

type Payout_Update_Fields struct {
}

type Payout_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Payout_Pk(v int64) Payout_Pk_Field {
	return Payout_Pk_Field{_set: true, _value: v}
}

func (f Payout_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Payout_Pk_Field) _Column() string { return "pk" }

type Payout_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Payout_CreatedAt(v time.Time) Payout_CreatedAt_Field {
	v = toUTC(v)
	return Payout_CreatedAt_Field{_set: true, _value: v}
}

func (f Payout_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Payout_CreatedAt_Field) _Column() string { return "created_at" }

type Payout_CsvLine_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Payout_CsvLine(v int) Payout_CsvLine_Field {
	return Payout_CsvLine_Field{_set: true, _value: v}
}

func (f Payout_CsvLine_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Payout_CsvLine_Field) _Column() string { return "csv_line" }

type Payout_Payee_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Payout_Payee(v string) Payout_Payee_Field {
	return Payout_Payee_Field{_set: true, _value: v}
}

func (f Payout_Payee_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Payout_Payee_Field) _Column() string { return "payee" }

type Payout_Usd_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Payout_Usd(v string) Payout_Usd_Field {
	return Payout_Usd_Field{_set: true, _value: v}
}

func (f Payout_Usd_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Payout_Usd_Field) _Column() string { return "usd" }

type Payout_PayoutGroupId_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Payout_PayoutGroupId(v int64) Payout_PayoutGroupId_Field {
	return Payout_PayoutGroupId_Field{_set: true, _value: v}
}

func (f Payout_PayoutGroupId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Payout_PayoutGroupId_Field) _Column() string { return "payout_group_id" }

type Transaction struct {
	Pk                int64
	CreatedAt         time.Time
	UpdatedAt         time.Time
	Hash              string
	Owner             string
	Spender           string
	Nonce             uint64
	EstimatedGasPrice string
	StorjPrice        string
	StorjTokens       string
	PayoutGroupId     int64
	Raw               string
	State             string
	Receipt           *string
}

func (Transaction) _Table() string { return "tx" }

type Transaction_Create_Fields struct {
	Receipt Transaction_Receipt_Field
}

type Transaction_Update_Fields struct {
	State   Transaction_State_Field
	Receipt Transaction_Receipt_Field
}

type Transaction_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Transaction_Pk(v int64) Transaction_Pk_Field {
	return Transaction_Pk_Field{_set: true, _value: v}
}

func (f Transaction_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_Pk_Field) _Column() string { return "pk" }

type Transaction_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Transaction_CreatedAt(v time.Time) Transaction_CreatedAt_Field {
	v = toUTC(v)
	return Transaction_CreatedAt_Field{_set: true, _value: v}
}

func (f Transaction_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_CreatedAt_Field) _Column() string { return "created_at" }

type Transaction_UpdatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Transaction_UpdatedAt(v time.Time) Transaction_UpdatedAt_Field {
	v = toUTC(v)
	return Transaction_UpdatedAt_Field{_set: true, _value: v}
}

func (f Transaction_UpdatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_UpdatedAt_Field) _Column() string { return "updated_at" }

type Transaction_Hash_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Transaction_Hash(v string) Transaction_Hash_Field {
	return Transaction_Hash_Field{_set: true, _value: v}
}

func (f Transaction_Hash_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_Hash_Field) _Column() string { return "hash" }

type Transaction_Owner_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Transaction_Owner(v string) Transaction_Owner_Field {
	return Transaction_Owner_Field{_set: true, _value: v}
}

func (f Transaction_Owner_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_Owner_Field) _Column() string { return "owner" }

type Transaction_Spender_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Transaction_Spender(v string) Transaction_Spender_Field {
	return Transaction_Spender_Field{_set: true, _value: v}
}

func (f Transaction_Spender_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_Spender_Field) _Column() string { return "spender" }

type Transaction_Nonce_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func Transaction_Nonce(v uint64) Transaction_Nonce_Field {
	return Transaction_Nonce_Field{_set: true, _value: v}
}

func (f Transaction_Nonce_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_Nonce_Field) _Column() string { return "nonce" }

type Transaction_EstimatedGasPrice_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Transaction_EstimatedGasPrice(v string) Transaction_EstimatedGasPrice_Field {
	return Transaction_EstimatedGasPrice_Field{_set: true, _value: v}
}

func (f Transaction_EstimatedGasPrice_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_EstimatedGasPrice_Field) _Column() string { return "estimated_gas_price" }

type Transaction_StorjPrice_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Transaction_StorjPrice(v string) Transaction_StorjPrice_Field {
	return Transaction_StorjPrice_Field{_set: true, _value: v}
}

func (f Transaction_StorjPrice_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_StorjPrice_Field) _Column() string { return "storj_price" }

type Transaction_StorjTokens_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Transaction_StorjTokens(v string) Transaction_StorjTokens_Field {
	return Transaction_StorjTokens_Field{_set: true, _value: v}
}

func (f Transaction_StorjTokens_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_StorjTokens_Field) _Column() string { return "storj_tokens" }

type Transaction_PayoutGroupId_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Transaction_PayoutGroupId(v int64) Transaction_PayoutGroupId_Field {
	return Transaction_PayoutGroupId_Field{_set: true, _value: v}
}

func (f Transaction_PayoutGroupId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_PayoutGroupId_Field) _Column() string { return "payout_group_id" }

type Transaction_Raw_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Transaction_Raw(v string) Transaction_Raw_Field {
	return Transaction_Raw_Field{_set: true, _value: v}
}

func (f Transaction_Raw_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_Raw_Field) _Column() string { return "raw" }

type Transaction_State_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Transaction_State(v string) Transaction_State_Field {
	return Transaction_State_Field{_set: true, _value: v}
}

func (f Transaction_State_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_State_Field) _Column() string { return "state" }

type Transaction_Receipt_Field struct {
	_set   bool
	_null  bool
	_value *string
}

func Transaction_Receipt(v string) Transaction_Receipt_Field {
	return Transaction_Receipt_Field{_set: true, _value: &v}
}

func Transaction_Receipt_Raw(v *string) Transaction_Receipt_Field {
	if v == nil {
		return Transaction_Receipt_Null()
	}
	return Transaction_Receipt(*v)
}

func Transaction_Receipt_Null() Transaction_Receipt_Field {
	return Transaction_Receipt_Field{_set: true, _null: true}
}

func (f Transaction_Receipt_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Transaction_Receipt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Transaction_Receipt_Field) _Column() string { return "receipt" }

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_cockroach struct{}

func (p __sqlbundle_cockroach) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgx struct{}

func (p __sqlbundle_pgx) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgxcockroach struct{}

func (p __sqlbundle_pgxcockroach) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime or possibly embed time
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string {
	if h.SQL == nil {
		return ""
	}
	return h.SQL.Render()
}

//
// end runtime support for building sql statements
//

type Version_Row struct {
	Version int
}

func (obj *sqlite3Impl) CreateNoReturn_Payout(ctx context.Context,
	payout_csv_line Payout_CsvLine_Field,
	payout_payee Payout_Payee_Field,
	payout_usd Payout_Usd_Field,
	payout_payout_group_id Payout_PayoutGroupId_Field) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__created_at_val := __now.UTC()
	__csv_line_val := payout_csv_line.value()
	__payee_val := payout_payee.value()
	__usd_val := payout_usd.value()
	__payout_group_id_val := payout_payout_group_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO payout ( created_at, csv_line, payee, usd, payout_group_id ) VALUES ( ?, ?, ?, ?, ? )")

	var __values []interface{}
	__values = append(__values, __created_at_val, __csv_line_val, __payee_val, __usd_val, __payout_group_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) CreateNoReturn_PayoutGroup(ctx context.Context,
	payout_group_id PayoutGroup_Id_Field,
	optional PayoutGroup_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__created_at_val := __now.UTC()
	__updated_at_val := __now.UTC()
	__id_val := payout_group_id.value()
	__final_tx_hash_val := optional.FinalTxHash.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO payout_group ( created_at, updated_at, id, final_tx_hash ) VALUES ( ?, ?, ?, ? )")

	var __values []interface{}
	__values = append(__values, __created_at_val, __updated_at_val, __id_val, __final_tx_hash_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) Create_Transaction(ctx context.Context,
	transaction_hash Transaction_Hash_Field,
	transaction_owner Transaction_Owner_Field,
	transaction_spender Transaction_Spender_Field,
	transaction_nonce Transaction_Nonce_Field,
	transaction_estimated_gas_price Transaction_EstimatedGasPrice_Field,
	transaction_storj_price Transaction_StorjPrice_Field,
	transaction_storj_tokens Transaction_StorjTokens_Field,
	transaction_payout_group_id Transaction_PayoutGroupId_Field,
	transaction_raw Transaction_Raw_Field,
	transaction_state Transaction_State_Field,
	optional Transaction_Create_Fields) (
	transaction *Transaction, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__created_at_val := __now.UTC()
	__updated_at_val := __now.UTC()
	__hash_val := transaction_hash.value()
	__owner_val := transaction_owner.value()
	__spender_val := transaction_spender.value()
	__nonce_val := transaction_nonce.value()
	__estimated_gas_price_val := transaction_estimated_gas_price.value()
	__storj_price_val := transaction_storj_price.value()
	__storj_tokens_val := transaction_storj_tokens.value()
	__payout_group_id_val := transaction_payout_group_id.value()
	__raw_val := transaction_raw.value()
	__state_val := transaction_state.value()
	__receipt_val := optional.Receipt.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO tx ( created_at, updated_at, hash, owner, spender, nonce, estimated_gas_price, storj_price, storj_tokens, payout_group_id, raw, state, receipt ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __values []interface{}
	__values = append(__values, __created_at_val, __updated_at_val, __hash_val, __owner_val, __spender_val, __nonce_val, __estimated_gas_price_val, __storj_price_val, __storj_tokens_val, __payout_group_id_val, __raw_val, __state_val, __receipt_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastTransaction(ctx, __pk)

}

func (obj *sqlite3Impl) CreateNoReturn_Metadata(ctx context.Context,
	metadata_version Metadata_Version_Field,
	metadata_attempts Metadata_Attempts_Field,
	optional Metadata_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__created_at_val := __now.UTC()
	__updated_at_val := __now.UTC()
	__version_val := metadata_version.value()
	__attempts_val := metadata_attempts.value()
	__spender_val := optional.Spender.value()
	__owner_val := optional.Owner.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO metadata ( created_at, updated_at, version, attempts, spender, owner ) VALUES ( ?, ?, ?, ?, ?, ? )")

	var __values []interface{}
	__values = append(__values, __created_at_val, __updated_at_val, __version_val, __attempts_val, __spender_val, __owner_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) All_Payout_By_PayoutGroupId(ctx context.Context,
	payout_payout_group_id Payout_PayoutGroupId_Field) (
	rows []*Payout, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT payout.pk, payout.created_at, payout.csv_line, payout.payee, payout.usd, payout.payout_group_id FROM payout WHERE payout.payout_group_id = ?")

	var __values []interface{}
	__values = append(__values, payout_payout_group_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		payout := &Payout{}
		err = __rows.Scan(&payout.Pk, &payout.CreatedAt, &payout.CsvLine, &payout.Payee, &payout.Usd, &payout.PayoutGroupId)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, payout)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Count_Payout_By_PayoutGroupId(ctx context.Context,
	payout_payout_group_id Payout_PayoutGroupId_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM payout WHERE payout.payout_group_id = ?")

	var __values []interface{}
	__values = append(__values, payout_payout_group_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) All_Transaction_By_PayoutGroupId(ctx context.Context,
	transaction_payout_group_id Transaction_PayoutGroupId_Field) (
	rows []*Transaction, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT tx.pk, tx.created_at, tx.updated_at, tx.hash, tx.owner, tx.spender, tx.nonce, tx.estimated_gas_price, tx.storj_price, tx.storj_tokens, tx.payout_group_id, tx.raw, tx.state, tx.receipt FROM tx WHERE tx.payout_group_id = ?")

	var __values []interface{}
	__values = append(__values, transaction_payout_group_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		transaction := &Transaction{}
		err = __rows.Scan(&transaction.Pk, &transaction.CreatedAt, &transaction.UpdatedAt, &transaction.Hash, &transaction.Owner, &transaction.Spender, &transaction.Nonce, &transaction.EstimatedGasPrice, &transaction.StorjPrice, &transaction.StorjTokens, &transaction.PayoutGroupId, &transaction.Raw, &transaction.State, &transaction.Receipt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, transaction)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_PayoutGroup_By_Pk(ctx context.Context,
	payout_group_pk PayoutGroup_Pk_Field) (
	payout_group *PayoutGroup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT payout_group.pk, payout_group.created_at, payout_group.updated_at, payout_group.id, payout_group.final_tx_hash FROM payout_group WHERE payout_group.pk = ?")

	var __values []interface{}
	__values = append(__values, payout_group_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	payout_group = &PayoutGroup{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&payout_group.Pk, &payout_group.CreatedAt, &payout_group.UpdatedAt, &payout_group.Id, &payout_group.FinalTxHash)
	if err != nil {
		return (*PayoutGroup)(nil), obj.makeErr(err)
	}
	return payout_group, nil

}

func (obj *sqlite3Impl) All_Payout(ctx context.Context) (
	rows []*Payout, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT payout.pk, payout.created_at, payout.csv_line, payout.payee, payout.usd, payout.payout_group_id FROM payout")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		payout := &Payout{}
		err = __rows.Scan(&payout.Pk, &payout.CreatedAt, &payout.CsvLine, &payout.Payee, &payout.Usd, &payout.PayoutGroupId)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, payout)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Payout_By_PayoutGroup_FinalTxHash_Is_Null(ctx context.Context) (
	rows []*Payout, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT payout.pk, payout.created_at, payout.csv_line, payout.payee, payout.usd, payout.payout_group_id FROM payout  JOIN payout_group ON payout.payout_group_id = payout_group.id WHERE payout_group.final_tx_hash is NULL")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		payout := &Payout{}
		err = __rows.Scan(&payout.Pk, &payout.CreatedAt, &payout.CsvLine, &payout.Payee, &payout.Usd, &payout.PayoutGroupId)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, payout)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Count_PayoutGroup(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM payout_group")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Count_PayoutGroup_By_FinalTxHash_Is_Null(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM payout_group WHERE payout_group.final_tx_hash is NULL")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) All_Transaction(ctx context.Context) (
	rows []*Transaction, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT tx.pk, tx.created_at, tx.updated_at, tx.hash, tx.owner, tx.spender, tx.nonce, tx.estimated_gas_price, tx.storj_price, tx.storj_tokens, tx.payout_group_id, tx.raw, tx.state, tx.receipt FROM tx")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		transaction := &Transaction{}
		err = __rows.Scan(&transaction.Pk, &transaction.CreatedAt, &transaction.UpdatedAt, &transaction.Hash, &transaction.Owner, &transaction.Spender, &transaction.Nonce, &transaction.EstimatedGasPrice, &transaction.StorjPrice, &transaction.StorjTokens, &transaction.PayoutGroupId, &transaction.Raw, &transaction.State, &transaction.Receipt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, transaction)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Count_Transaction(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM tx")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Count_Transaction_By_State(ctx context.Context,
	transaction_state Transaction_State_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM tx WHERE tx.state = ?")

	var __values []interface{}
	__values = append(__values, transaction_state.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) All_Transaction_By_State_OrderBy_Asc_Nonce(ctx context.Context,
	transaction_state Transaction_State_Field) (
	rows []*Transaction, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT tx.pk, tx.created_at, tx.updated_at, tx.hash, tx.owner, tx.spender, tx.nonce, tx.estimated_gas_price, tx.storj_price, tx.storj_tokens, tx.payout_group_id, tx.raw, tx.state, tx.receipt FROM tx WHERE tx.state = ? ORDER BY tx.nonce")

	var __values []interface{}
	__values = append(__values, transaction_state.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		transaction := &Transaction{}
		err = __rows.Scan(&transaction.Pk, &transaction.CreatedAt, &transaction.UpdatedAt, &transaction.Hash, &transaction.Owner, &transaction.Spender, &transaction.Nonce, &transaction.EstimatedGasPrice, &transaction.StorjPrice, &transaction.StorjTokens, &transaction.PayoutGroupId, &transaction.Raw, &transaction.State, &transaction.Receipt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, transaction)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Find_PayoutGroup_By_Id(ctx context.Context,
	payout_group_id PayoutGroup_Id_Field) (
	payout_group *PayoutGroup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT payout_group.pk, payout_group.created_at, payout_group.updated_at, payout_group.id, payout_group.final_tx_hash FROM payout_group WHERE payout_group.id = ?")

	var __values []interface{}
	__values = append(__values, payout_group_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	payout_group = &PayoutGroup{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&payout_group.Pk, &payout_group.CreatedAt, &payout_group.UpdatedAt, &payout_group.Id, &payout_group.FinalTxHash)
	if err == sql.ErrNoRows {
		return (*PayoutGroup)(nil), nil
	}
	if err != nil {
		return (*PayoutGroup)(nil), obj.makeErr(err)
	}
	return payout_group, nil

}

func (obj *sqlite3Impl) Find_Transaction_By_Hash(ctx context.Context,
	transaction_hash Transaction_Hash_Field) (
	transaction *Transaction, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT tx.pk, tx.created_at, tx.updated_at, tx.hash, tx.owner, tx.spender, tx.nonce, tx.estimated_gas_price, tx.storj_price, tx.storj_tokens, tx.payout_group_id, tx.raw, tx.state, tx.receipt FROM tx WHERE tx.hash = ?")

	var __values []interface{}
	__values = append(__values, transaction_hash.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	transaction = &Transaction{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&transaction.Pk, &transaction.CreatedAt, &transaction.UpdatedAt, &transaction.Hash, &transaction.Owner, &transaction.Spender, &transaction.Nonce, &transaction.EstimatedGasPrice, &transaction.StorjPrice, &transaction.StorjTokens, &transaction.PayoutGroupId, &transaction.Raw, &transaction.State, &transaction.Receipt)
	if err == sql.ErrNoRows {
		return (*Transaction)(nil), nil
	}
	if err != nil {
		return (*Transaction)(nil), obj.makeErr(err)
	}
	return transaction, nil

}

func (obj *sqlite3Impl) First_Metadata(ctx context.Context) (
	metadata *Metadata, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT metadata.pk, metadata.created_at, metadata.updated_at, metadata.version, metadata.attempts, metadata.spender, metadata.owner FROM metadata LIMIT 1 OFFSET 0")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	metadata = &Metadata{}
	err = __rows.Scan(&metadata.Pk, &metadata.CreatedAt, &metadata.UpdatedAt, &metadata.Version, &metadata.Attempts, &metadata.Spender, &metadata.Owner)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return metadata, nil

}

func (obj *sqlite3Impl) First_Metadata_Version(ctx context.Context) (
	row *Version_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT metadata.version FROM metadata LIMIT 1 OFFSET 0")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	row = &Version_Row{}
	err = __rows.Scan(&row.Version)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return row, nil

}

func (obj *sqlite3Impl) UpdateNoReturn_PayoutGroup_By_Id(ctx context.Context,
	payout_group_id PayoutGroup_Id_Field,
	update PayoutGroup_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE payout_group SET "), __sets, __sqlbundle_Literal(" WHERE payout_group.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.FinalTxHash._set {
		__values = append(__values, update.FinalTxHash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("final_tx_hash = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))

	__args = append(__args, payout_group_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) UpdateNoReturn_Transaction_By_Hash(ctx context.Context,
	transaction_hash Transaction_Hash_Field,
	update Transaction_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE tx SET "), __sets, __sqlbundle_Literal(" WHERE tx.hash = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.State._set {
		__values = append(__values, update.State.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("state = ?"))
	}

	if update.Receipt._set {
		__values = append(__values, update.Receipt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("receipt = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))

	__args = append(__args, transaction_hash.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) UpdateNoReturn_Metadata_By_Pk(ctx context.Context,
	metadata_pk Metadata_Pk_Field,
	update Metadata_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE metadata SET "), __sets, __sqlbundle_Literal(" WHERE metadata.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Attempts._set {
		__values = append(__values, update.Attempts.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("attempts = ?"))
	}

	if update.Spender._set {
		__values = append(__values, update.Spender.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("spender = ?"))
	}

	if update.Owner._set {
		__values = append(__values, update.Owner.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("owner = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))

	__args = append(__args, metadata_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) getLastPayout(ctx context.Context,
	pk int64) (
	payout *Payout, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT payout.pk, payout.created_at, payout.csv_line, payout.payee, payout.usd, payout.payout_group_id FROM payout WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	payout = &Payout{}
	err = obj.driver.QueryRowContext(ctx, __stmt, pk).Scan(&payout.Pk, &payout.CreatedAt, &payout.CsvLine, &payout.Payee, &payout.Usd, &payout.PayoutGroupId)
	if err != nil {
		return (*Payout)(nil), obj.makeErr(err)
	}
	return payout, nil

}

func (obj *sqlite3Impl) getLastPayoutGroup(ctx context.Context,
	pk int64) (
	payout_group *PayoutGroup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT payout_group.pk, payout_group.created_at, payout_group.updated_at, payout_group.id, payout_group.final_tx_hash FROM payout_group WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	payout_group = &PayoutGroup{}
	err = obj.driver.QueryRowContext(ctx, __stmt, pk).Scan(&payout_group.Pk, &payout_group.CreatedAt, &payout_group.UpdatedAt, &payout_group.Id, &payout_group.FinalTxHash)
	if err != nil {
		return (*PayoutGroup)(nil), obj.makeErr(err)
	}
	return payout_group, nil

}

func (obj *sqlite3Impl) getLastTransaction(ctx context.Context,
	pk int64) (
	transaction *Transaction, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT tx.pk, tx.created_at, tx.updated_at, tx.hash, tx.owner, tx.spender, tx.nonce, tx.estimated_gas_price, tx.storj_price, tx.storj_tokens, tx.payout_group_id, tx.raw, tx.state, tx.receipt FROM tx WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	transaction = &Transaction{}
	err = obj.driver.QueryRowContext(ctx, __stmt, pk).Scan(&transaction.Pk, &transaction.CreatedAt, &transaction.UpdatedAt, &transaction.Hash, &transaction.Owner, &transaction.Spender, &transaction.Nonce, &transaction.EstimatedGasPrice, &transaction.StorjPrice, &transaction.StorjTokens, &transaction.PayoutGroupId, &transaction.Raw, &transaction.State, &transaction.Receipt)
	if err != nil {
		return (*Transaction)(nil), obj.makeErr(err)
	}
	return transaction, nil

}

func (obj *sqlite3Impl) getLastMetadata(ctx context.Context,
	pk int64) (
	metadata *Metadata, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT metadata.pk, metadata.created_at, metadata.updated_at, metadata.version, metadata.attempts, metadata.spender, metadata.owner FROM metadata WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	metadata = &Metadata{}
	err = obj.driver.QueryRowContext(ctx, __stmt, pk).Scan(&metadata.Pk, &metadata.CreatedAt, &metadata.UpdatedAt, &metadata.Version, &metadata.Attempts, &metadata.Spender, &metadata.Owner)
	if err != nil {
		return (*Metadata)(nil), obj.makeErr(err)
	}
	return metadata, nil

}

func (impl sqlite3Impl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(sqlite3.Error); ok {
		if e.Code == sqlite3.ErrConstraint {
			msg := err.Error()
			colon := strings.LastIndex(msg, ":")
			if colon != -1 {
				return strings.TrimSpace(msg[colon:]), true
			}
			return "", true
		}
	}
	return "", false
}

func (obj *sqlite3Impl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM tx;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM payout;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM payout_group;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM metadata;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Rx struct {
	db *DB
	tx *Tx
}

func (rx *Rx) UnsafeTx(ctx context.Context) (unsafe_tx *sql.Tx, err error) {
	tx, err := rx.getTx(ctx)
	if err != nil {
		return nil, err
	}
	return tx.Tx, nil
}

func (rx *Rx) getTx(ctx context.Context) (tx *Tx, err error) {
	if rx.tx == nil {
		if rx.tx, err = rx.db.Open(ctx); err != nil {
			return nil, err
		}
	}
	return rx.tx, nil
}

func (rx *Rx) Rebind(s string) string {
	return rx.db.Rebind(s)
}

func (rx *Rx) Commit() (err error) {
	if rx.tx != nil {
		err = rx.tx.Commit()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) Rollback() (err error) {
	if rx.tx != nil {
		err = rx.tx.Rollback()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) All_Payout(ctx context.Context) (
	rows []*Payout, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Payout(ctx)
}

func (rx *Rx) All_Payout_By_PayoutGroupId(ctx context.Context,
	payout_payout_group_id Payout_PayoutGroupId_Field) (
	rows []*Payout, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Payout_By_PayoutGroupId(ctx, payout_payout_group_id)
}

func (rx *Rx) All_Payout_By_PayoutGroup_FinalTxHash_Is_Null(ctx context.Context) (
	rows []*Payout, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Payout_By_PayoutGroup_FinalTxHash_Is_Null(ctx)
}

func (rx *Rx) All_Transaction(ctx context.Context) (
	rows []*Transaction, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Transaction(ctx)
}

func (rx *Rx) All_Transaction_By_PayoutGroupId(ctx context.Context,
	transaction_payout_group_id Transaction_PayoutGroupId_Field) (
	rows []*Transaction, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Transaction_By_PayoutGroupId(ctx, transaction_payout_group_id)
}

func (rx *Rx) All_Transaction_By_State_OrderBy_Asc_Nonce(ctx context.Context,
	transaction_state Transaction_State_Field) (
	rows []*Transaction, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Transaction_By_State_OrderBy_Asc_Nonce(ctx, transaction_state)
}

func (rx *Rx) Count_PayoutGroup(ctx context.Context) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Count_PayoutGroup(ctx)
}

func (rx *Rx) Count_PayoutGroup_By_FinalTxHash_Is_Null(ctx context.Context) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Count_PayoutGroup_By_FinalTxHash_Is_Null(ctx)
}

func (rx *Rx) Count_Payout_By_PayoutGroupId(ctx context.Context,
	payout_payout_group_id Payout_PayoutGroupId_Field) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Count_Payout_By_PayoutGroupId(ctx, payout_payout_group_id)
}

func (rx *Rx) Count_Transaction(ctx context.Context) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Count_Transaction(ctx)
}

func (rx *Rx) Count_Transaction_By_State(ctx context.Context,
	transaction_state Transaction_State_Field) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Count_Transaction_By_State(ctx, transaction_state)
}

func (rx *Rx) CreateNoReturn_Metadata(ctx context.Context,
	metadata_version Metadata_Version_Field,
	metadata_attempts Metadata_Attempts_Field,
	optional Metadata_Create_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_Metadata(ctx, metadata_version, metadata_attempts, optional)

}

func (rx *Rx) CreateNoReturn_Payout(ctx context.Context,
	payout_csv_line Payout_CsvLine_Field,
	payout_payee Payout_Payee_Field,
	payout_usd Payout_Usd_Field,
	payout_payout_group_id Payout_PayoutGroupId_Field) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_Payout(ctx, payout_csv_line, payout_payee, payout_usd, payout_payout_group_id)

}

func (rx *Rx) CreateNoReturn_PayoutGroup(ctx context.Context,
	payout_group_id PayoutGroup_Id_Field,
	optional PayoutGroup_Create_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_PayoutGroup(ctx, payout_group_id, optional)

}

func (rx *Rx) Create_Transaction(ctx context.Context,
	transaction_hash Transaction_Hash_Field,
	transaction_owner Transaction_Owner_Field,
	transaction_spender Transaction_Spender_Field,
	transaction_nonce Transaction_Nonce_Field,
	transaction_estimated_gas_price Transaction_EstimatedGasPrice_Field,
	transaction_storj_price Transaction_StorjPrice_Field,
	transaction_storj_tokens Transaction_StorjTokens_Field,
	transaction_payout_group_id Transaction_PayoutGroupId_Field,
	transaction_raw Transaction_Raw_Field,
	transaction_state Transaction_State_Field,
	optional Transaction_Create_Fields) (
	transaction *Transaction, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Transaction(ctx, transaction_hash, transaction_owner, transaction_spender, transaction_nonce, transaction_estimated_gas_price, transaction_storj_price, transaction_storj_tokens, transaction_payout_group_id, transaction_raw, transaction_state, optional)

}

func (rx *Rx) Find_PayoutGroup_By_Id(ctx context.Context,
	payout_group_id PayoutGroup_Id_Field) (
	payout_group *PayoutGroup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_PayoutGroup_By_Id(ctx, payout_group_id)
}

func (rx *Rx) Find_Transaction_By_Hash(ctx context.Context,
	transaction_hash Transaction_Hash_Field) (
	transaction *Transaction, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_Transaction_By_Hash(ctx, transaction_hash)
}

func (rx *Rx) First_Metadata(ctx context.Context) (
	metadata *Metadata, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.First_Metadata(ctx)
}

func (rx *Rx) First_Metadata_Version(ctx context.Context) (
	row *Version_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.First_Metadata_Version(ctx)
}

func (rx *Rx) Get_PayoutGroup_By_Pk(ctx context.Context,
	payout_group_pk PayoutGroup_Pk_Field) (
	payout_group *PayoutGroup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_PayoutGroup_By_Pk(ctx, payout_group_pk)
}

func (rx *Rx) UpdateNoReturn_Metadata_By_Pk(ctx context.Context,
	metadata_pk Metadata_Pk_Field,
	update Metadata_Update_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.UpdateNoReturn_Metadata_By_Pk(ctx, metadata_pk, update)
}

func (rx *Rx) UpdateNoReturn_PayoutGroup_By_Id(ctx context.Context,
	payout_group_id PayoutGroup_Id_Field,
	update PayoutGroup_Update_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.UpdateNoReturn_PayoutGroup_By_Id(ctx, payout_group_id, update)
}

func (rx *Rx) UpdateNoReturn_Transaction_By_Hash(ctx context.Context,
	transaction_hash Transaction_Hash_Field,
	update Transaction_Update_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.UpdateNoReturn_Transaction_By_Hash(ctx, transaction_hash, update)
}

type Methods interface {
	All_Payout(ctx context.Context) (
		rows []*Payout, err error)

	All_Payout_By_PayoutGroupId(ctx context.Context,
		payout_payout_group_id Payout_PayoutGroupId_Field) (
		rows []*Payout, err error)

	All_Payout_By_PayoutGroup_FinalTxHash_Is_Null(ctx context.Context) (
		rows []*Payout, err error)

	All_Transaction(ctx context.Context) (
		rows []*Transaction, err error)

	All_Transaction_By_PayoutGroupId(ctx context.Context,
		transaction_payout_group_id Transaction_PayoutGroupId_Field) (
		rows []*Transaction, err error)

	All_Transaction_By_State_OrderBy_Asc_Nonce(ctx context.Context,
		transaction_state Transaction_State_Field) (
		rows []*Transaction, err error)

	Count_PayoutGroup(ctx context.Context) (
		count int64, err error)

	Count_PayoutGroup_By_FinalTxHash_Is_Null(ctx context.Context) (
		count int64, err error)

	Count_Payout_By_PayoutGroupId(ctx context.Context,
		payout_payout_group_id Payout_PayoutGroupId_Field) (
		count int64, err error)

	Count_Transaction(ctx context.Context) (
		count int64, err error)

	Count_Transaction_By_State(ctx context.Context,
		transaction_state Transaction_State_Field) (
		count int64, err error)

	CreateNoReturn_Metadata(ctx context.Context,
		metadata_version Metadata_Version_Field,
		metadata_attempts Metadata_Attempts_Field,
		optional Metadata_Create_Fields) (
		err error)

	CreateNoReturn_Payout(ctx context.Context,
		payout_csv_line Payout_CsvLine_Field,
		payout_payee Payout_Payee_Field,
		payout_usd Payout_Usd_Field,
		payout_payout_group_id Payout_PayoutGroupId_Field) (
		err error)

	CreateNoReturn_PayoutGroup(ctx context.Context,
		payout_group_id PayoutGroup_Id_Field,
		optional PayoutGroup_Create_Fields) (
		err error)

	Create_Transaction(ctx context.Context,
		transaction_hash Transaction_Hash_Field,
		transaction_owner Transaction_Owner_Field,
		transaction_spender Transaction_Spender_Field,
		transaction_nonce Transaction_Nonce_Field,
		transaction_estimated_gas_price Transaction_EstimatedGasPrice_Field,
		transaction_storj_price Transaction_StorjPrice_Field,
		transaction_storj_tokens Transaction_StorjTokens_Field,
		transaction_payout_group_id Transaction_PayoutGroupId_Field,
		transaction_raw Transaction_Raw_Field,
		transaction_state Transaction_State_Field,
		optional Transaction_Create_Fields) (
		transaction *Transaction, err error)

	Find_PayoutGroup_By_Id(ctx context.Context,
		payout_group_id PayoutGroup_Id_Field) (
		payout_group *PayoutGroup, err error)

	Find_Transaction_By_Hash(ctx context.Context,
		transaction_hash Transaction_Hash_Field) (
		transaction *Transaction, err error)

	First_Metadata(ctx context.Context) (
		metadata *Metadata, err error)

	First_Metadata_Version(ctx context.Context) (
		row *Version_Row, err error)

	Get_PayoutGroup_By_Pk(ctx context.Context,
		payout_group_pk PayoutGroup_Pk_Field) (
		payout_group *PayoutGroup, err error)

	UpdateNoReturn_Metadata_By_Pk(ctx context.Context,
		metadata_pk Metadata_Pk_Field,
		update Metadata_Update_Fields) (
		err error)

	UpdateNoReturn_PayoutGroup_By_Id(ctx context.Context,
		payout_group_id PayoutGroup_Id_Field,
		update PayoutGroup_Update_Fields) (
		err error)

	UpdateNoReturn_Transaction_By_Hash(ctx context.Context,
		transaction_hash Transaction_Hash_Field,
		update Transaction_Update_Fields) (
		err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() string
	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx *sql.Tx) txMethods
	makeErr(err error) error
}

//lint:file-ignore SA4021,ST1000,ST1003,ST1012,ST1016,U1000 dbx generated code

func opensqlite3(source string) (*sql.DB, error) {
	return sql.Open("sqlite3", source)
}
